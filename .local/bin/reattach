#!/bin/sh

set -e
set -u

usage() {
    local exitcode out_fd
    case $# in
        0) exitcode=0; out_fd=1 ;;
        *) exitcode="$1"; out_fd=2; shift ;;
    esac
    echo "Usage: reattach [session name] [screen options]" >&"$out_fd"
    exit "$exitcode"
}

while getopts "h" option; do
    case "$option" in
        h) usage ;;
        "?") usage 2 ;;
    esac
done
shift $(( $OPTIND - 1 ))
case $# in
    0) session_name=default ;;
    *) session_name="$1"; shift ;;
esac

read screen_flags screen_name <<EOF
$(screen -S "$session_name" -ls | awk '
($5 ~ /\)$/) {sn=$1}
($5 == "(Detached)") {dn=$1}
END {print dn ? "-r " dn : "-x " sn}
')
EOF
# For reasons I don't fully understand, on Debian <11, starting a screen from
# inside a screen (e.g., over SSH) causes screen to use a more limited terminal.
# Switch back to what we originally connected with so the new/reattached screen
# can use the full set of terminal capabilities.
export TERM="${TERM#screen.}"
if [ -n "$screen_name" ]; then
    pkill -USR2 --parent "${screen_name%%.*}" 'sh$'
    exec screen "$screen_flags" "$screen_name"
elif [ -e "/var/lib/systemd/linger/$USER" ]; then
    exec systemd-run \
         --user --scope \
         --unit="screen-${session_name}-$(date --iso-8601=seconds)" \
         screen "$@" -S "$session_name"
else
    exec screen "$@" -S "$session_name"
fi
